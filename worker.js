export const covidWorker=()=>{const DefaultConfiguration={undefined:!1,fieldSeparator:",",lineSeparator:"\n",quote:'"'},fieldValue=(cell,options)=>{if(!options.undefined||cell.length)return cell},addField=(field,row,state)=>{row.push(field),state.field++,state.fieldOffset=-1,state.appendField=!1},addRow=(row,rows,state)=>{rows.push(row),state.field=0,state.line++,state.lineOffset=-1,state.appendRow=!1},csv2json=(text,configuration=DefaultConfiguration)=>new Promise(resolve=>{((text,configuration=DefaultConfiguration)=>{const options=Object.assign({},DefaultConfiguration,configuration),state={field:0,fieldOffset:0,line:0,lineOffset:0,quoted:!1,appendCell:!1,appendField:!1,appendRow:!1};return new Promise((resolve,reject)=>{if(text.length){const rows=[];let row=[],cell="";for(let idx=0;idx<text.length;idx++)state.appendCell=!0,text[idx]===options.quote?idx&&"\\"!==text[idx-1]?(!cell.length||state.quoted?state.quoted=!state.quoted:reject(Error(`Invalid CSV text at offset ${state.line}:${state.lineOffset}`)),state.appendCell=!1):cell=cell.substr(0,cell.length-1):text[idx]===options.fieldSeparator?state.quoted||(state.appendCell=!1,state.appendField=!0):text[idx]===options.lineSeparator&&(state.quoted||(state.appendCell=!1,state.appendField=!0,state.appendRow=!0)),state.appendCell&&(cell+=text[idx]),state.appendField&&(addField(fieldValue(cell,options),row,state),cell=""),state.appendRow&&(addRow(row,rows,state),row=[]),state.lineOffset++,state.fieldOffset++;row.length&&(addField(fieldValue(cell,options),row,state),addRow(row,rows,state)),resolve(rows)}else reject(Error("Empty CSV text"))})})(text,configuration).then(rows=>{const keys=rows[0].filter(field=>"string"==typeof field);resolve(rows.filter((row,idx)=>idx>0).map(row=>{const obj={};return keys.forEach((key,keyIdx)=>{obj[key]=row[keyIdx]}),obj}))})});class ModelMapper{map(rows){return rows.map(row=>this._map(row)).sort((a,b)=>{const diff=a.country.localeCompare(b.country);return 0===diff?a.state.localeCompare(b.state):diff})}_map(row){const temp={values:[]};return Object.keys(row).forEach(key=>{if(key.match(/State/))temp.state=row[key];else if(key.match(/Country/))temp.country=row[key].replace(/\*/,"");else if(key.match(/Lat/))temp.lat=parseFloat(row[key]);else if(key.match(/Long/))temp.lon=parseFloat(row[key]);else{const value=parseInt(row[key],10),date=new Date(key),timestamp=Date.UTC(date.getFullYear(),date.getMonth(),date.getDate());temp.values.push({timestamp,value})}}),temp.values.sort((a,b)=>a.timestamp-b.timestamp),Object.freeze(temp)}}class LookupMapper{map(rows){return rows.map(row=>this._map(row)).sort((a,b)=>{const diff=a.country.localeCompare(b.country);return 0===diff?a.state.localeCompare(b.state):diff})}_map(row){const temp={};return Object.keys(row).forEach(key=>{key.match(/State/)?temp.state=row[key]:key.match(/Country/)?temp.country=row[key].replace(/\*/,""):key.match(/Lat/)?temp.lat=parseFloat(row[key]):key.match(/Long/)?temp.lon=parseFloat(row[key]):key.match(/Population/)?temp.population=parseInt(row[key]):key.match(/UID/)?temp.uid=parseInt(row[key]):key.match(/iso2/)?temp.iso2=row[key]:key.match(/iso3/)?temp.iso3=row[key]:key.match(/code3/)?temp.code3=parseInt(row[key]):key.match(/FIPS/)?temp.fips=parseInt(row[key]):key.match(/Admin2/)&&(temp.admin2=row[key])}),Object.freeze(temp)}}let Type;!function(Type){Type.CONFIRMED="confirmed",Type.DEATHS="deaths",Type.RECOVERED="recovered",Type.LOOKUP="lookup"}(Type||(Type={}));class ModelCollector{constructor(_modelMapper=new ModelMapper,_lookupMapper=new LookupMapper){this._modelMapper=_modelMapper,this._lookupMapper=_lookupMapper}async collect(){const lookup=await this._fetchLookup(),confirmed=await this._fetchModel(Type.CONFIRMED),deaths=await this._fetchModel(Type.DEATHS),resolved=await this._fetchModel(Type.RECOVERED);return this.merge(confirmed,deaths,resolved,lookup)}findSeries(timestamp,series){const found=series.find(temp=>temp.timestamp===timestamp);return found?found.value:0}async merge(confirmed,deaths,recovered,lookups){return new Promise(resolve=>{const models=confirmed.filter(dummy=>"Canada"!==dummy.country||"Recovered"!==dummy.state).map(model=>{const lookup=lookups.find(dummy=>{let ret=dummy.country.localeCompare(model.country);return 0===ret&&(ret=dummy.state.localeCompare(model.state)),0===ret}),modelDeaths=deaths.find(dummy=>dummy.country===model.country&&dummy.state===model.state),modelRecovered=recovered.find(dummy=>dummy.country===model.country&&dummy.state===model.state),values=model.values.map(value=>Object.freeze({confirmed:value.value,deaths:this.findSeries(value.timestamp,modelDeaths?modelDeaths.values:[]),recovered:this.findSeries(value.timestamp,modelRecovered?modelRecovered.values:[]),timestamp:value.timestamp}));return Object.freeze({country:model.country,lat:model.lat,lon:model.lon,state:model.state,population:lookup&&lookup.population||0,values:Object.freeze(values)})});resolve(Object.freeze(models))})}async _fetchModel(type){return this._fetch(type).then(text=>csv2json(text)).then(models=>this._modelMapper.map(models))}async _fetchLookup(){return this._fetch(Type.LOOKUP).then(text=>csv2json(text)).then(models=>this._lookupMapper.map(models))}async _fetch(type){return fetch(this._fetchUrl(type),{headers:this._fetchHeaders(),method:"GET"}).then(response=>response.text())}_fetchHeaders(){return{"Accept-Encoding":"gzip, deflate, br"}}_fetchUrl(type){return type===Type.LOOKUP?"https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/UID_ISO_FIPS_LookUp_Table.csv":`https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data//csse_covid_19_time_series/time_series_covid19_${type}_global.csv`}}self.onmessage=e=>{if(e)return console.log(self),!0===e.data?(self.postMessage(!1),void self.close()):void(new ModelCollector).collect().then(model=>{self.postMessage(model)}).catch(e=>{self.postMessage(e)}).finally(()=>{self.close()})}};export default covidWorker;